# Домашнее задание №4

Реализовать волновой алгоритм.

## Решение: Реализация на примере тонкостенного лабиринта

### Алгоритм формирования лабиринта

В данной реализации алгоритм работает на дискретном рабочем поле, представляющем
собой ограниченную прямоугольную область, разбитую на квадратные ячейки.

Любая из 4-х сторон любой ячейки может иметь стену или быть проходимой (не иметь стены).

Стена между любой парой смежных ячеек является общей для данных ячеек.

1. В начале формирования лабиринта все ячейки объявляются закрытыми со всех сторон.

2. Выбирается любая исходная текущая ячейка внутри поля и
	1. Ячейка помечаетя как посещённая
	2. И помещается в стек.

3. Далее, до тех пор пока на поле остаются непосещённые ячейки, выполняется следующий алгоритм:

	* В случае, если у текущей ячейки имеется хотя бы одна непосещённая соседняя ячейка:
		1. Случайным образом выбирается одна из таких непосещённых соседних ячеек.
		2. Между текущей и выбранной ячейкой удаляется стена.
		3. Выбранная ячейка помечается как посещённая.
		4. Выбранная ячейка помещается в стек.
		5. Выбранная ячейка делается текущей ячейкой.
	
	* В противном случае:
		1. Из стека извлекается ячейка.
		2. Извлечённая ячейка делается текущей ячейкой.

### Алгоритм поиска кратчайшего пути

Применяется алгоритм волновой трассировки, принадлежащий к алгоритмам, основанным на методах *поиска в ширину*. *Поиск в ширину* работает путём последовательного просмотра отдельных *уровней* графа, начиная с узла источника, в противовес стратегии *поиска в глубину*, при которой развёртываются все уровни для текущей периферии дерева поиска, вплоть до самого глубокого узла.

Применительно к данному приложению, под уровнем графа подразумевается всё множество ячеек, достижимое за одно и то же количество шагов, отсчитываемых от стартовой ячейки. А роль связного дерева выполняет матричное представление поля, содержащее атрибуты каждой ячейки (посещена/не посещена и уровень или номер шага, на котором ячейка была достигнута).

Назначение *стартовой* и *финишной ячеек* условно, достаточно указание любой пары ячеек внутри поля, между которыми нужно найти кратчайший путь.

Основная идея алгоритма: на каждом шаге, для множества ячеек, соответствующих данному шагу, выясняется нет ли в данном множестве финишной ячейки, и если финишная ячейка ещё не достигнута, для следующего шага порождается новое множество из соседних ещё не посещённых ячеек.

Таким образом, весь алгоритм поиска включает этапы распространения волны и восстановление пути.

*Этап распространения волны:*

От стартовой ячейки порождаются возможные шаги в соседние ячейки, при условии что рассматриваемая соседняя ячейка достижима (нет стены между ней и текущей) и не помечена как ранее посещённая.

При выполнении указанных условий для рассматриваемой соседней ячейки в её атрибуты заносится номер шага, отсчитываемый от стартовой ячейки и факт посещения.

Проверяется, является ли рассматриваемая ячейка финишной.

Если в процессе порождения новой волны финишная ячейка ещё не достигнута, то алгоритм повторяется для каждой ячейки новой волны: каждая такая ячейка принимается за стартовую, и из неё порождаются очередные шаги в соседние ячейки и т.д.

При таком переборе будет найден путь от начальной ячейки к конечной, либо очередной шаг из любой порождённой в пути ячейки будет невозможен.

*Этап восстановления пути:*

Восстановление кратчайшего пути происходит в обратном направлении: при выборе ячейки от финишной ячейки к стартовой на каждом шаге выбирается ячейка, имеющая атрибут номера шага от стартовой на единицу меньше текущей ячейки. Очевидно, что таким образом находится кратчайший путь между парой заданных ячеек.

В общем случае может существовать несколько возможных кратчайших путей из стартовой ячейки к финишной.

### Пример работы приложения:

*Примечание:* Различием в цвете обозначаются ответвления найденных альтернативных путей той же минимально возможной длины.


